# 工具配置原理

> **本文档说明**：ccman 如何配置 Claude Code、Codex、Gemini CLI、OpenCode 四个工具，以及各工具的配置文件如何起作用。

---

## 一、配置架构概览

### 1. 三层架构

```
┌─────────────────────────────────────────────────────────────┐
│                     用户操作层 (CLI/Desktop)                  │
│  ccman add/edit/switch/remove                                │
└─────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────┐
│                   管理层 (ToolManager)                        │
│  - 统一 Provider 数据模型                                     │
│  - 统一 CRUD 操作                                            │
│  - 配置文件：~/.ccman/{tool}.json                            │
└─────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────┐
│                    写入层 (Writers)                           │
│  - writeClaudeConfig()  → ~/.claude/settings.json           │
│  - writeCodexConfig()   → ~/.codex/config.toml + auth.json  │
│  - writeGeminiConfig()  → ~/.gemini/settings.json + .env    │
│  - writeOpenCodeConfig() → ~/.config/opencode/opencode.json │
└─────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────┐
│                  工具读取配置并生效                            │
│  Claude Code / Codex / Gemini CLI / OpenCode                │
└─────────────────────────────────────────────────────────────┘
```

### 2. 核心数据模型

**Provider（服务商）**：
```typescript
interface Provider {
  id: string           // 唯一标识，格式：{tool}-{timestamp}-{random}
  name: string         // 显示名称，如 "GMN"
  desc?: string        // 描述
  baseUrl: string      // API 基础 URL
  apiKey: string       // API 密钥
  model?: string       // 模型名称或 JSON 元数据
  createdAt: number    // 创建时间戳
  lastModified: number // 最后修改时间戳
  lastUsedAt?: number  // 最后使用时间戳
}
```

**ToolConfig（工具配置）**：
```typescript
interface ToolConfig {
  providers: Provider[]        // Provider 列表
  presets: PresetTemplate[]    // 用户自定义预设
  currentProviderId?: string   // 当前激活的 Provider ID
}
```

---

## 二、Claude Code 配置原理

### 1. 配置文件路径

```
~/.claude/settings.json
```

### 2. 配置文件结构

```json
{
  "env": {
    "ANTHROPIC_AUTH_TOKEN": "sk-ant-xxx",
    "ANTHROPIC_BASE_URL": "https://gmn.chuangzuoli.com/api",
    "CLAUDE_CODE_DISABLE_NONESSENTIAL_TRAFFIC": 1,
    "CLAUDE_CODE_MAX_OUTPUT_TOKENS": 32000
  },
  "permissions": {
    "allow": [],
    "deny": []
  }
}
```

### 3. 关键字段说明

| 字段 | 作用 | ccman 管理 |
|------|------|-----------|
| `env.ANTHROPIC_AUTH_TOKEN` | API 密钥 | ✅ 强制覆盖 |
| `env.ANTHROPIC_BASE_URL` | API 基础 URL | ✅ 强制覆盖 |
| `env.CLAUDE_CODE_DISABLE_NONESSENTIAL_TRAFFIC` | 禁用非必要流量 | ✅ 默认值 1 |
| `env.CLAUDE_CODE_MAX_OUTPUT_TOKENS` | 最大输出 Token 数 | ✅ 默认值 32000 |
| `permissions` | 权限配置 | ❌ 保留用户配置 |

### 4. 写入策略（零破坏性）

**代码位置**：`packages/core/src/writers/claude.ts`

**流程**：
```typescript
// 1. 读取用户现有配置
let userConfig = {}
if (fileExists(configPath)) {
  userConfig = JSON.parse(fs.readFileSync(configPath, 'utf-8'))
}

// 2. 替换模板变量，生成默认配置
const defaultConfig = replaceVariables(CLAUDE_CONFIG_TEMPLATE, {
  apiKey: provider.apiKey,
  baseUrl: provider.baseUrl,
})

// 3. 深度合并：默认配置为基础，用户配置覆盖
const mergedConfig = deepMerge(defaultConfig, userConfig)

// 4. 强制更新认证字段为最新值
mergedConfig.env.ANTHROPIC_AUTH_TOKEN = provider.apiKey
mergedConfig.env.ANTHROPIC_BASE_URL = provider.baseUrl

// 5. 写入配置文件
fs.writeFileSync(configPath, JSON.stringify(mergedConfig, null, 2))
```

**保证**：
- ✅ 用户的 `permissions` 配置不会丢失
- ✅ 用户的其他 `env` 变量不会丢失
- ✅ 认证字段始终是最新的

### 5. Claude Code 如何读取配置

**启动时**：
1. 读取 `~/.claude/settings.json`
2. 从 `env.ANTHROPIC_AUTH_TOKEN` 获取 API Key
3. 从 `env.ANTHROPIC_BASE_URL` 获取 Base URL
4. 使用这些配置连接 API 服务

**环境变量优先级**：
```
系统环境变量 > settings.json 中的 env > 默认值
```

---

## 三、Codex 配置原理

### 1. 配置文件路径

```
~/.codex/config.toml    # 主配置
~/.codex/auth.json      # 认证信息
```

### 2. config.toml 结构

```toml
model_provider = "gmn"
model = "gpt-5.2-codex"
model_reasoning_effort = "high"
model_verbosity = "high"
web_search = "live"
disable_response_storage = true
sandbox_mode = "workspace-write"
windows_wsl_setup_acknowledged = true

[sandbox_workspace_write]
network_access = true

[model_providers.gmn]
name = "gmn"
base_url = "https://gmn.chuangzuoli.com"
wire_api = "responses"
requires_openai_auth = true
```

### 3. auth.json 结构

```json
{
  "OPENAI_API_KEY": "sk-ant-xxx"
}
```

### 4. 关键字段说明

| 字段 | 作用 | ccman 管理 |
|------|------|-----------|
| `model_provider` | 当前使用的服务商 key | ✅ GMN 固定写入 `gmn`（其他服务商默认使用 provider.name） |
| `model` | 当前使用的模型 | ✅ 设置为 provider.model 或保留现有值 |
| `model_providers[name]` | 服务商配置 | ✅ 添加/更新当前 providerKey |
| `model_reasoning_effort` | 推理强度 | ✅ 默认 `high`（用户可覆盖） |
| `model_verbosity` | 输出详细度 | ✅ 默认 `high`（用户可覆盖） |
| `web_search` | 联网搜索策略 | ✅ 默认 `live`（用户可覆盖） |
| `disable_response_storage` | 禁用响应存储 | ✅ 默认 `true`（用户可覆盖） |
| `sandbox_mode` | 沙箱模式 | ✅ 默认 `workspace-write`（用户可覆盖） |
| `sandbox_workspace_write.network_access` | workspace-write 是否允许联网 | ✅ 默认 `true`（用户可覆盖） |

### 5. 写入策略（零破坏性）

**代码位置**：`packages/core/src/writers/codex.ts`

**流程**：
```typescript
// 1. 读取现有配置
let userConfig = {}
if (fileExists(configPath)) {
  userConfig = parseToml(fs.readFileSync(configPath, 'utf-8'))
}

// 2. 深度合并（用户配置优先）
const mergedConfig = deepMerge(templateConfig, userConfig)

// 3. 设置 Provider 相关字段
mergedConfig.model_provider = providerKey
mergedConfig.model = provider.model || mergedConfig.model || 'gpt-5.2-codex'

// 4. 设置 model_providers
mergedConfig.model_providers = mergedConfig.model_providers || {}
mergedConfig.model_providers[providerKey] = {
  name: providerKey,
  base_url: provider.baseUrl,
  wire_api: 'responses',
  requires_openai_auth: true,
}

// 5. 写入 config.toml
fs.writeFileSync(configPath, stringifyToml(mergedConfig))

// 6. 更新 auth.json（只修改 OPENAI_API_KEY）
let auth = fileExists(authPath) ? JSON.parse(fs.readFileSync(authPath)) : {}
auth.OPENAI_API_KEY = provider.apiKey
fs.writeFileSync(authPath, JSON.stringify(auth, null, 2))
```

**保证**：
- ✅ 用户的 `model_reasoning_effort`、`features` 等配置不会丢失
- ✅ 其他服务商的 `model_providers` 配置不会丢失
- ✅ `auth.json` 中的其他字段不会丢失

**注意**：
- ⚠️ TOML 解析器会丢失注释（已知限制）
- ⚠️ 如果需要保留注释，建议放在单独的文档文件中

### 6. Codex 如何读取配置

**启动时**：
1. 读取 `~/.codex/config.toml`
2. 从 `model_provider` 获取当前服务商名称
3. 从 `model_providers[name]` 获取服务商配置
4. 读取 `~/.codex/auth.json` 获取 API Key
5. 使用这些配置连接 API 服务

**配置优先级**：
```
命令行参数 > config.toml > 默认值
```

---

## 四、Gemini CLI 配置原理

### 1. 配置文件路径

```
~/.gemini/settings.json    # 主配置
~/.gemini/.env             # 环境变量
```

### 2. settings.json 结构

```json
{
  "ide": {
    "enabled": true
  },
  "security": {
    "auth": {
      "selectedType": "gemini-api-key"
    }
  }
}
```

### 3. .env 结构

```bash
GEMINI_API_KEY=sk-ant-xxx
GEMINI_MODEL=gemini-2.5-pro
GOOGLE_GEMINI_BASE_URL=https://gmn.chuangzuoli.com
```

### 4. 关键字段说明

| 字段 | 作用 | ccman 管理 |
|------|------|-----------|
| `ide.enabled` | 启用 IDE 集成 | ✅ 确保为 true |
| `security.auth.selectedType` | 认证方式 | ✅ 默认 "gemini-api-key" |
| `GEMINI_API_KEY` | API 密钥 | ✅ 设置为 provider.apiKey |
| `GOOGLE_GEMINI_BASE_URL` | API 基础 URL | ✅ 设置为 provider.baseUrl |
| `GEMINI_MODEL` | 模型名称 | ✅ 设置为 provider.model |

### 5. 写入策略（零破坏性）

**代码位置**：`packages/core/src/writers/gemini.ts`

**流程**：
```typescript
// 1. 更新 settings.json
let settings = fileExists(settingsPath) ? JSON.parse(fs.readFileSync(settingsPath)) : {}

// 确保启用 IDE 集成
settings.ide = settings.ide || {}
if (settings.ide.enabled === undefined) {
  settings.ide.enabled = true
}

// 配置认证方式（默认值，不覆盖用户自定义）
settings.security = settings.security || {}
settings.security.auth = settings.security.auth || {}
if (settings.security.auth.selectedType === undefined) {
  settings.security.auth.selectedType = 'gemini-api-key'
}

fs.writeFileSync(settingsPath, JSON.stringify(settings, null, 2))

// 2. 更新 .env
const env = loadEnvFile(envPath) // 简单解析 KEY=VALUE

// 设置环境变量
if (provider.baseUrl) env.GOOGLE_GEMINI_BASE_URL = provider.baseUrl
if (provider.apiKey) env.GEMINI_API_KEY = provider.apiKey

// 处理 provider.model（可能是 JSON 元数据或纯字符串）
if (provider.model) {
  try {
    const meta = JSON.parse(provider.model)
    // 合并 meta.env 到 .env
    if (meta.env) Object.assign(env, meta.env)
    // fallback: 如果没有 GEMINI_MODEL，从 defaultModel 提取
    if (!env.GEMINI_MODEL && meta.defaultModel) {
      env.GEMINI_MODEL = meta.defaultModel
    }
  } catch {
    // 不是 JSON，当作普通模型名称
    env.GEMINI_MODEL = provider.model
  }
}

saveEnvFile(envPath, env) // 按 KEY 排序写入
```

**保证**：
- ✅ 用户的其他 `settings.json` 配置不会丢失
- ✅ 用户的其他 `.env` 变量不会丢失
- ✅ 支持 JSON 元数据（高级用法）

### 6. Gemini CLI 如何读取配置

**启动时**：
1. 读取 `~/.gemini/settings.json`
2. 检查 `ide.enabled` 是否为 true
3. 读取 `~/.gemini/.env` 获取环境变量
4. 从 `GEMINI_API_KEY` 获取 API Key
5. 从 `GOOGLE_GEMINI_BASE_URL` 获取 Base URL
6. 从 `GEMINI_MODEL` 获取模型名称
7. 使用这些配置连接 API 服务

**环境变量优先级**：
```
系统环境变量 > ~/.gemini/.env > 默认值
```

---

## 五、OpenCode 配置原理

### 1. 配置文件路径

```
~/.config/opencode/opencode.json
```

### 2. 配置文件结构

```json
{
  "$schema": "https://opencode.ai/config.json",
  "provider": {
    "gmn": {
      "npm": "@ai-sdk/openai",
      "name": "GMN",
      "options": {
        "baseURL": "https://gmn.chuangzuoli.com",
        "apiKey": "sk-ant-xxx"
      },
      "models": {
        "gpt-5.2-codex": {
          "variants": {
            "xhigh": {
              "reasoningEffort": "xhigh",
              "textVerbosity": "low",
              "reasoningSummary": "auto"
            },
            "high": { "reasoningEffort": "high", "textVerbosity": "low", "reasoningSummary": "auto" },
            "medium": { "reasoningEffort": "medium", "textVerbosity": "low", "reasoningSummary": "auto" },
            "low": { "reasoningEffort": "low", "textVerbosity": "low", "reasoningSummary": "auto" }
          }
        }
      }
    }
  }
}
```

### 3. 关键字段说明

| 字段 | 作用 | ccman 管理 |
|------|------|-----------|
| `$schema` | JSON Schema URL | ✅ 固定值 |
| `provider[key].npm` | npm 包名 | ✅ 默认 "@ai-sdk/openai" |
| `provider[key].name` | 显示名称 | ✅ 设置为 provider.name |
| `provider[key].options.baseURL` | API 基础 URL | ✅ 设置为 provider.baseUrl |
| `provider[key].options.apiKey` | API 密钥 | ✅ 设置为 provider.apiKey |
| `provider[key].models` | 模型配置 | ✅ 默认包含 gpt-5.2-codex 变体 |

**Provider Key 生成规则**：
```typescript
function toProviderKey(name: string): string {
  return name.trim().toLowerCase()
    .replace(/\s+/g, '-')           // 空格 → 中划线
    .replace(/[^a-z0-9-_]/g, '')    // 移除非法字符
    || 'provider'                    // fallback
}

// 示例：
// "GMN" → "gmn"
// "OpenAI Official" → "openai-official"
```

### 4. 写入策略（零破坏性）

**代码位置**：`packages/core/src/writers/opencode.ts`

**流程**：
```typescript
// 1. 读取现有配置
const existingConfig = fileExists(configPath) ? readJSON(configPath) : {}

// 2. 解析 provider.model（可能是 JSON 元数据）
const meta = parseProviderMeta(provider.model)
const npmPackage = meta?.npm || '@ai-sdk/openai'
const models = meta?.models || DEFAULT_MODELS

// 3. 生成 provider key
const providerKey = toProviderKey(provider.name)

// 4. 构建 provider 配置（保留现有的其他字段）
const existingProvider = existingConfig.provider?.[providerKey]
const providerConfig = {
  ...existingProvider,
  npm: npmPackage,
  name: provider.name,
  options: {
    ...(existingProvider?.options || {}),
    baseURL: provider.baseUrl,
    apiKey: provider.apiKey,
  },
  models,
}

// 5. 合并配置
const nextConfig = {
  ...existingConfig,
  $schema: 'https://opencode.ai/config.json',
  provider: {
    ...(existingConfig.provider || {}),
    [providerKey]: providerConfig,
  },
}

// 6. 写入配置文件
writeJSON(configPath, nextConfig)
```

**保证**：
- ✅ 其他 provider 的配置不会丢失
- ✅ 当前 provider 的其他字段（如自定义 options）不会丢失
- ✅ 支持 JSON 元数据（自定义 npm 包和 models）

### 5. OpenCode 如何读取配置

**启动时**：
1. 读取 `~/.config/opencode/opencode.json`
2. 遍历 `provider` 对象
3. 对于每个 provider：
   - 从 `npm` 字段加载对应的 AI SDK 包
   - 从 `options.baseURL` 和 `options.apiKey` 初始化客户端
   - 从 `models` 字段获取可用模型列表
4. 使用这些配置连接 API 服务

**配置优先级**：
```
opencode.json > 默认值
```

---

## 六、配置同步机制

### 1. 何时触发配置写入

**ToolManager 操作**：
```typescript
manager.switch(id)  // ✅ 立即写入配置
manager.edit(id, updates)  // ✅ 如果是当前激活的 provider，立即写入
manager.add(input)  // ❌ 不写入（需要手动 switch）
manager.remove(id)  // ❌ 不写入（只删除 provider 数据）
```

**特殊情况（MCP）**：
```typescript
// MCP 配置了 autoSync: true
manager.add(input)    // ✅ 立即同步到 ~/.claude.json
manager.edit(id, updates)  // ✅ 立即同步
manager.remove(id)    // ✅ 立即同步
```

### 2. 配置文件关系

```
用户操作
  ↓
~/.ccman/{tool}.json (Provider 数据)
  ↓
ToolManager.switch()
  ↓
Writer 函数
  ↓
工具官方配置文件
  ↓
工具读取并生效
```

**数据流向**：
- **单向**：ccman → 工具配置文件
- **不回读**：工具配置文件的手动修改不会同步回 ccman

### 3. 配置冲突处理

**场景 1：用户手动修改了工具配置文件**
```
用户修改 ~/.claude/settings.json
  ↓
ccman switch 到另一个 provider
  ↓
用户的手动修改会被保留（深度合并策略）
  ↓
只有认证字段会被覆盖
```

**场景 2：用户在工具中切换了服务商**
```
用户在 Codex 中手动修改 model_provider
  ↓
ccman 不会感知到这个变化
  ↓
ccman switch 会覆盖用户的修改
```

**建议**：
- ✅ 使用 ccman 统一管理服务商切换
- ❌ 不要在工具中手动修改服务商配置

---

## 七、高级用法：JSON 元数据

### 1. Gemini CLI 的 JSON 元数据

**场景**：需要设置多个环境变量

```typescript
// 添加 provider 时，model 字段使用 JSON
manager.add({
  name: 'Custom Gemini',
  baseUrl: 'https://api.example.com',
  apiKey: 'sk-xxx',
  model: JSON.stringify({
    defaultModel: 'gemini-2.5-pro',
    env: {
      GEMINI_MODEL: 'gemini-2.5-pro',
      GEMINI_TEMPERATURE: '0.7',
      GEMINI_MAX_TOKENS: '8192',
    },
  }),
})
```

**写入结果**（~/.gemini/.env）：
```bash
GEMINI_API_KEY=sk-xxx
GEMINI_MAX_TOKENS=8192
GEMINI_MODEL=gemini-2.5-pro
GEMINI_TEMPERATURE=0.7
GOOGLE_GEMINI_BASE_URL=https://api.example.com
```

### 2. OpenCode 的 JSON 元数据

**场景**：使用自定义 npm 包和模型配置

```typescript
manager.add({
  name: 'Custom OpenAI',
  baseUrl: 'https://api.example.com',
  apiKey: 'sk-xxx',
  model: JSON.stringify({
    npm: '@ai-sdk/custom',
    models: {
      'custom-model': {
        variants: {
          high: { reasoningEffort: 'high', textVerbosity: 'low', reasoningSummary: 'auto' },
        },
      },
    },
  }),
})
```

**写入结果**（~/.config/opencode/opencode.json）：
```json
{
  "provider": {
    "custom-openai": {
      "npm": "@ai-sdk/custom",
      "name": "Custom OpenAI",
      "options": {
        "baseURL": "https://api.example.com",
        "apiKey": "sk-xxx"
      },
      "models": {
        "custom-model": {
          "variants": {
            "high": { "reasoningEffort": "high", "textVerbosity": "low", "reasoningSummary": "auto" }
          }
        }
      }
    }
  }
}
```

---

## 八、故障排查

### 1. 配置未生效

**症状**：执行 `ccman switch` 后，工具仍然使用旧配置

**排查步骤**：
```bash
# 1. 确认 ccman 配置正确
ccman {tool} current

# 2. 检查工具配置文件是否更新
cat ~/.claude/settings.json  # Claude
cat ~/.codex/config.toml     # Codex
cat ~/.gemini/.env           # Gemini
cat ~/.config/opencode/opencode.json  # OpenCode

# 3. 重启工具
# 大多数工具需要重启才能读取新配置
```

**常见原因**：
- ❌ 工具未重启
- ❌ 工具使用了缓存的配置
- ❌ 工具从其他位置读取配置（环境变量优先级更高）

### 2. 配置被覆盖

**症状**：用户的自定义配置丢失

**排查步骤**：
```bash
# 1. 检查是否是认证字段
# 认证字段（apiKey, baseUrl）会被强制覆盖，这是预期行为

# 2. 检查是否是其他字段
# 其他字段应该被保留，如果丢失，可能是 bug

# 3. 查看备份文件（如果有）
ls -la ~/.claude/settings.json.bak
```

**解决方案**：
- ✅ 认证字段：使用 ccman 管理，不要手动修改
- ✅ 其他字段：应该被保留，如果丢失请报告 bug

### 3. TOML 注释丢失（Codex）

**症状**：`~/.codex/config.toml` 中的注释消失

**原因**：TOML 解析器的已知限制

**解决方案**：
- ✅ 将注释放在单独的文档文件中
- ✅ 或者接受注释丢失（配置数据不会丢失）

---

## 九、总结

### 1. 核心原则

**零破坏性**：
- ✅ 只修改认证相关字段
- ✅ 保留用户的其他自定义配置
- ✅ 使用深度合并策略

**统一管理**：
- ✅ 所有工具共用同一套 Provider 数据模型
- ✅ 统一的 CRUD 操作接口
- ✅ 统一的配置写入流程

**简洁实现**：
- ✅ 每个 Writer 只做一件事：写入配置
- ✅ 没有复杂的抽象层
- ✅ 直接硬编码 4 个 Writer 函数

### 2. 配置文件对照表

| 工具 | 配置文件 | 认证字段 | 其他重要字段 |
|------|---------|---------|-------------|
| Claude Code | `~/.claude/settings.json` | `env.ANTHROPIC_AUTH_TOKEN`<br>`env.ANTHROPIC_BASE_URL` | `permissions` |
| Codex | `~/.codex/config.toml`<br>`~/.codex/auth.json` | `model_provider`<br>`model_providers[name]`<br>`OPENAI_API_KEY` | `model_reasoning_effort`<br>`features` |
| Gemini CLI | `~/.gemini/settings.json`<br>`~/.gemini/.env` | `GEMINI_API_KEY`<br>`GOOGLE_GEMINI_BASE_URL` | `ide.enabled`<br>`security.auth.selectedType` |
| OpenCode | `~/.config/opencode/opencode.json` | `provider[key].options.baseURL`<br>`provider[key].options.apiKey` | `provider[key].npm`<br>`provider[key].models` |

### 3. 下一步

- [ ] 阅读 [技术架构](./技术架构.md) 了解 ToolManager 和 Writer 的实现细节
- [ ] 阅读 [GMN 快速配置脚本](./GMN快速配置脚本.md) 了解如何批量配置
- [ ] 阅读 [开发规范](../CLAUDE.md) 了解项目开发原则
