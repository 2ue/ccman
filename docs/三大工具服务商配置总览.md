# 三大工具（Claude Code / Codex / Gemini CLI）服务商配置总览

本项目的核心目标是：用一套统一的「服务商（Provider）」配置，驱动三个开发工具的实际配置文件：

- Claude Code（`~/.claude/settings.json`）
- Codex（`~/.codex/config.toml` + `~/.codex/auth.json`）
- Gemini CLI（`~/.gemini/settings.json` + `~/.gemini/.env`）

本文从 ccman 的实现角度，说明这三个工具的服务商是如何被配置和映射的，便于排查问题或进行手动调试。

---

## 一、统一的 Provider 抽象

在 `@ccman/types` 中，所有工具共享同一套 Provider 结构（见 `packages/types/src/index.ts`）：

- `id`: 唯一 ID（形如 `codex-1732000000000-abc123`）
- `name`: 服务商显示名称（如 `openai`、`serverA`）
- `desc`: 描述（可选，仅用于 UI 展示）
- `baseUrl`: API Base URL
- `apiKey`: API Key（密钥）
- `model`: 模型相关信息（可选，仅 Codex / Gemini 使用）

ccman 会把这些 Provider 信息保存在：

- `~/.ccman/claude.json`（Claude）
- `~/.ccman/codex.json`（Codex）
- `~/.ccman/gemini.json`（Gemini）

当你执行：

- `ccman cc use <id>` / `ccman cc add`
- `ccman cx use <id>` / `ccman cx add`
- `ccman gm use <id>` / `ccman gm add`

CLI 会通过 `@ccman/core` 的 `ToolManager` 和对应的 `writer`，把当前 Provider 写入各工具的官方配置文件中。

---

## 二、Claude Code 服务商配置

### 1. 官方配置路径

- 主目录：`~/.claude/`
- 设置文件：`~/.claude/settings.json`

官方文档说明（见 `docs/官方文档/claude/settings.md`）：

- `settings.json` 中的 `env` 字段用于注入环境变量
- Claude Code 运行时会读取这些环境变量来决定 API 地址和认证方式

### 2. ccman 写入逻辑

核心实现见：`packages/core/src/writers/claude.ts` 中的 `writeClaudeConfig`。

ccman 做了几件事：

1. **加载模板配置**
   - 优先读取 `packages/core/templates/claude/settings.json`（如果存在）
   - 否则使用内置的 `CLAUDE_CONFIG_TEMPLATE`
2. **替换模板变量**
   - `{{apiKey}}` → 当前 Provider 的 `apiKey`
   - `{{baseUrl}}` → 当前 Provider 的 `baseUrl`
3. **与用户现有配置深度合并**
   - 旧配置优先，确保不会覆盖用户自定义字段
4. **强制覆盖关键认证字段**
   - `env.ANTHROPIC_AUTH_TOKEN = provider.apiKey`
   - `env.ANTHROPIC_BASE_URL = provider.baseUrl`

实际生效的关键配置示例：

```jsonc
{
  "env": {
    "ANTHROPIC_AUTH_TOKEN": "sk-ant-xxx",
    "ANTHROPIC_BASE_URL": "https://api.anthropic.com",
    "CLAUDE_CODE_DISABLE_NONESSENTIAL_TRAFFIC": 1,
    "CLAUDE_CODE_MAX_OUTPUT_TOKENS": 32000
  },
  "permissions": {
    "allow": [],
    "deny": []
  }
}
```

### 3. 和 Provider 的对应关系

- Provider 的 `baseUrl` → `env.ANTHROPIC_BASE_URL`
- Provider 的 `apiKey` → `env.ANTHROPIC_AUTH_TOKEN`
- 其他字段（如 `model`）当前不写入 Claude 配置，仅保存在 `~/.ccman/claude.json` 中

---

## 三、Codex 服务商配置

### 1. 官方配置路径

- 主目录：`~/.codex/`
- 主配置：`~/.codex/config.toml`
- 认证配置：`~/.codex/auth.json`

官方文档（精简自 `docs/官方文档/codex/config.md`）：

- `config.toml` 中的：
  - `model_provider`：当前使用的服务商名称
  - `[model_providers.<name>]`：各个服务商的 base_url 等信息
- `auth.json` 中的：
  - `OPENAI_API_KEY`：当前使用的 API 密钥

### 2. ccman 写入逻辑

核心实现见：`packages/core/src/writers/codex.ts` 中的 `writeCodexConfig`。

大致流程：

1. **读取并解析现有 `config.toml`**
2. **与内置默认配置（`CODEX_DEFAULT_CONFIG` 或模板）做深度合并**
3. **根据 Provider 更新以下字段：**
   - `model_provider = provider.name`
   - `model = provider.model || 现有 model || 'gpt-5-codex'`
   - `model_providers[provider.name] = { name, base_url, wire_api, requires_openai_auth }`
4. **写回 `config.toml`（TOML 注释会丢失，但所有键值保留）**
5. **更新 `auth.json` 中的 `OPENAI_API_KEY = provider.apiKey`**

示例（合并后的关键片段）：

```toml
model_provider = "serverA"
model = "gpt-5-codex"

[model_providers.serverA]
name = "serverA"
base_url = "https://codex-api.serverA.com/v1"
wire_api = "responses"
requires_openai_auth = true
```

`auth.json`：

```json
{
  "OPENAI_API_KEY": "sk-proj-xxx..."
}
```

### 3. 和 Provider 的对应关系

- Provider 的 `name` → `model_provider` 及 `[model_providers.<name>].name`
- Provider 的 `baseUrl` → `[model_providers.<name>].base_url`
- Provider 的 `apiKey` → `auth.json.OPENAI_API_KEY`
- Provider 的 `model` → 顶层 `model`（如果提供）

---

## 四、Gemini CLI 服务商配置

### 1. 官方配置路径

- 主目录：`~/.gemini/`
- 设置文件：`~/.gemini/settings.json`
- 环境文件：`~/.gemini/.env`

官方文档（`docs/官方文档/gemini/config.md`）要点：

- `settings.json` 负责整体配置（UI、IDE、Sandbox、Security 等）
- 字符串值支持 `$VAR_NAME` / `${VAR_NAME}` 引用环境变量
- 认证相关放在 `security.auth.*`，具体细节在 Authentication 文档

### 2. ccman 写入逻辑

核心实现见：`packages/core/src/writers/gemini.ts` 中的 `writeGeminiConfig`。

#### 2.1 更新 `settings.json`

逻辑概要：

1. 如果文件存在则解析，否则从空对象开始
2. 确保 IDE 集成开启：
   - `settings.ide.enabled = true`（若未设置）
3. 确保认证方式默认使用 API Key：
   - 初始化 `settings.security.auth` 对象
   - **仅在未设置时** 写入 `selectedType = "gemini-api-key"`，尽量不覆盖用户自定义配置
4. 原子写入（先写 `settings.json.tmp`，再 `rename` 替换）

#### 2.2 更新 `~/.gemini/.env`

1. 读取现有 `.env`，按 `KEY=VALUE` 解析
2. 根据 Provider 更新：
   - `provider.baseUrl` → `GOOGLE_GEMINI_BASE_URL`（为空则删除此行）
   - `provider.apiKey` → `GEMINI_API_KEY`（为空则删除此行）
3. 处理 `provider.model`：
   - 如果是普通字符串：直接写入 `GEMINI_MODEL=<字符串>`
   - 如果是 JSON 字符串：视为元数据，结构类似：
     ```json
     {
       "defaultModel": "gemini-2.5-pro",
       "env": {
         "GEMINI_MODEL": "gemini-2.5-pro",
         "EXTRA_FLAG": "1"
       }
     }
     ```
   - ccman 会：
     - 将 `env` 中的键值合并到 `.env`
     - 若最终仍不存在 `GEMINI_MODEL`，则使用 `defaultModel`
4. 最终把所有键按字母序排序后写回 `.env`

### 3. 和 Provider 的对应关系

- Provider 的 `baseUrl` → `.env.GOOGLE_GEMINI_BASE_URL`（可为空，表示使用官方默认）
- Provider 的 `apiKey` → `.env.GEMINI_API_KEY`（可为空，表示使用已有环境配置）
- Provider 的 `model`：
  - 普通字符串 → `.env.GEMINI_MODEL`
  - JSON 元数据 → `.env` 中多个键（`GEMINI_MODEL` + 自定义 env）

---

## 五、ccman 与官方配置的分层关系

整体上可以理解为三层：

1. **ccman 层（统一管理层）**
   - 配置文件：`~/.ccman/*.json`
   - 主要负责：维护 Provider 列表 / 当前选中 Provider / 预置列表
2. **各工具官方配置层**
   - Claude：`~/.claude/settings.json`
   - Codex：`~/.codex/config.toml` + `~/.codex/auth.json`
   - Gemini CLI：`~/.gemini/settings.json` + `~/.gemini/.env`
3. **运行时行为层**
   - 各工具在启动时读取自己的配置文件和环境变量，完成真正的鉴权和路由

ccman 的所有「服务商切换」操作，本质上都是：

> 读取 `~/.ccman/*.json` 中的 Provider → 用对应的 writer 更新官方配置文件 → 工具下次启动时生效。

理解了这一层映射关系，就能快速定位问题是出在：

- Provider 数据本身（`~/.ccman/*.json`）
- ccman 写入逻辑（`packages/core/src/writers/*.ts`）
- 还是工具官方配置被手动改坏（`~/.claude` / `~/.codex` / `~/.gemini`）。

