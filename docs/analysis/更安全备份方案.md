# 更安全的备份方案（设计与落地）

## 1. 安全目标

目标不是“有 `.bak` 就行”，而是实现以下保证：

1. 可恢复：任何写失败都能恢复到写前状态。
2. 可追溯：每次变更有唯一事务号和元数据（时间、命令、影响文件）。
3. 一致性：CLI、Desktop、ai-coding 行为一致。
4. 最小泄露：备份文件权限严格，避免敏感信息外泄。
5. 可维护：统一 API，避免各模块重复实现备份逻辑。

## 2. 风险模型（当前主要风险）

1. 写成功但无备份：用户误改后无回滚点。
2. 部分文件写成功、部分失败：跨文件状态不一致。
3. 并发写入：多个命令交错导致覆盖。
4. 临时回滚替代落盘备份：进程退出后无法恢复。
5. 备份无限增长或命名不统一：难以清理和运维。

## 3. 建议架构：统一“备份事务层”

在 `packages/core/src/utils` 新增统一模块（建议名：`backup-transaction.ts`），对外提供：

1. `beginBackupTransaction(context)`
2. `backupFileIfExists(filePath)`
3. `commit()`
4. `rollback()`

上下文建议包含：
- `operation`: 命令或动作标识（如 `codex.switch`, `desktop.write-config-files`）
- `actor`: `cli | desktop | aicoding | sync`
- `timestamp`
- `txId`

备份目录建议：
- `~/.ccman/backups/<yyyy-mm-dd>/<txId>/`

元数据文件建议：
- `manifest.json`（记录原路径、备份路径、hash、size、结果、错误）

## 4. 写入流程（安全版本）

每个会写文件的动作统一走以下流程：

1. 计算“将被修改的全部文件列表”。
2. 为每个已存在文件创建备份（并记录到 manifest）。
3. 对所有目标文件执行原子写（tmp + rename）。
4. 任一步失败则触发 `rollback()`，恢复全部已备份文件。
5. 成功后 `commit()`，写入最终状态并返回备份路径。

关键点：
- 先备份、后写入。
- 回滚是“全量回滚”，不是局部回滚。
- 不允许“备份失败但继续写”这种降级路径（可通过配置显式放开）。

## 5. 具体加固策略

1. 权限最小化
- 所有备份文件 `chmod 0o600`。
- 备份目录 `0o700`。

2. 路径白名单
- 仅允许备份与写入受控目录：`~/.ccman`、各官方工具配置目录。
- 防止 Desktop 编辑器传入任意路径导致越权写入。

3. 并发互斥
- 加文件锁（例如 `~/.ccman/.lock`）或进程级互斥。
- 同一时刻只允许一个写事务。

4. 完整性校验
- 备份时记录 hash（至少 sha256）和文件大小。
- 回滚后可选验证 hash，一致才视为恢复成功。

5. 留存策略
- 默认保留最近 N 个事务或最近 D 天。
- 支持按操作类型保留（如 `sync` 保留更多）。

6. 脱敏策略（可选）
- 对包含 API Key 的备份可选加密存储（如用户提供本地恢复密码）。
- 若不加密，必须明确 UI/CLI 警告其敏感性。

## 6. 分模块落地优先级

## Phase 1（必须）

1. ToolManager 全链路接入事务备份
- 覆盖 `add/edit/remove/clone/switch` 和 preset 写入。

2. 非 Codex writer 全部接入
- `claude/gemini/opencode/openclaw/mcp`。

3. Desktop 两个“配置编辑器写入”改为调用统一事务层
- `write-config-files`
- `write-ccman-config-files`

## Phase 2（应做）

4. `config.ts`（sync config）保存前备份。
5. `clean` 的单条删除与清空操作补齐备份。
6. `mcp:toggle-app` 写入目标配置前备份。

## Phase 3（一致性）

7. `ai-coding` 复用 core 事务层或迁移到 core writer。
8. import/export 支持文件集与备份策略统一。

## 7. 验收标准（建议）

1. 任意写命令返回结果中包含 `backupTxId` 或 `backupPaths`。
2. 强制故障注入（写到一半抛错）后，目标文件全部恢复。
3. 并发压测下无交叉覆盖。
4. 备份清理后目录可控，且最近事务可恢复。
5. CLI/Desktop/ai-coding 对同一动作的备份行为一致。

## 8. 立即可执行的最小改造

1. 在 core 增加统一备份事务工具。
2. 先接入 ToolManager + writers（覆盖大多数命令）。
3. Desktop 编辑器改为走 core API 或复用同一事务工具。
4. 最后处理 clean 与 ai-coding 的边缘写入。

这样能在最短路径下，把“有备份”升级为“可恢复、可追溯、跨端一致”的备份体系。
