# 新工具添加指南（Step-by-Step）

> 完整的新工具添加流程，从零到完成
>
> **示例工具：** CodeBuddy CLI

---

## 一、概述

### 1.1 添加新工具的成本

| 项目 | 成本 |
|------|------|
| **文件数量** | 5-6 个文件 |
| **代码量** | 约 200-300 行 |
| **修改现有代码** | 1 行（工具注册）|
| **CLI 命令** | 0 行（自动生成）|
| **Desktop UI** | 0 行（自动渲染）|

### 1.2 需要实现的内容

1. **ToolDescriptor** - 工具描述符
2. **ConfigAdapter** - 配置文件适配器（可选，如果需要直接操作配置文件）
3. **ServiceAdapter** - 服务商适配器（可选，如果支持服务商管理）
4. **McpAdapter** - MCP 适配器（可选，如果支持 MCP）
5. **Presets** - 预设列表（可选，如果有内置预设）
6. **Templates** - 配置模板文件（可选，如果需要模板）

---

## 二、准备工作

### 2.1 了解目标工具

以 **CodeBuddy CLI** 为例，假设它的配置如下：

**配置文件位置：**
- `~/.codebuddy/config.json`

**配置结构：**
```json
{
  "api_endpoint": "https://api.codebuddy.com/v1",
  "api_key": "cb-xxx",
  "model": "gpt-4-codebuddy",
  "other_settings": {
    "auto_save": true,
    "theme": "dark"
  }
}
```

**需求分析：**
- ✅ 支持服务商管理（`api_endpoint` 和 `api_key`）
- ❌ 不支持 MCP
- ✅ 有配置文件需要管理

---

## 三、创建工具目录

### 3.1 目录结构

```bash
packages/core/tools/codebuddy-cli/
├── descriptor.ts        # 工具描述符
├── config-adapter.ts    # 配置适配器
├── service-adapter.ts   # 服务商适配器
├── presets.ts           # 预设列表（可选）
└── index.ts             # 导出
```

### 3.2 创建目录

```bash
cd packages/core
mkdir -p tools/codebuddy-cli
```

---

## 四、实现 ToolDescriptor

### 4.1 创建 `descriptor.ts`

```typescript
// packages/core/tools/codebuddy-cli/descriptor.ts
import { ToolDescriptor } from '@ccman/types';
import { CodeBuddyConfigAdapter } from './config-adapter.js';
import { CodeBuddyServiceAdapter } from './service-adapter.js';
import { CODEBUDDY_PRESETS } from './presets.js';

export const codebuddyDescriptor: ToolDescriptor = {
  // ========== 基础信息 ==========
  id: 'codebuddy-cli',
  short: 'cb',
  displayName: 'CodeBuddy CLI',
  description: 'AI-powered code assistant',

  // ========== 配置路径 ==========
  configPaths: [
    {
      id: 'main',
      path: '~/.codebuddy/config.json',
      format: 'json',
      scope: 'user',
    },
  ],

  // ========== 适配器 ==========
  adapters: {
    config: new CodeBuddyConfigAdapter(),
    service: new CodeBuddyServiceAdapter(),
    // mcp: undefined (不支持 MCP)
  },

  // ========== 模板 ==========
  templates: [
    {
      pathId: 'main',
      templatePath: 'templates/codebuddy-cli/config.json',
    },
  ],

  // ========== 预设 ==========
  presets: CODEBUDDY_PRESETS,

  // ========== 能力声明 ==========
  capabilities: ['service', 'config'],  // 支持服务商和配置管理，不支持 MCP
};
```

---

## 五、实现 ConfigAdapter

### 5.1 创建 `config-adapter.ts`

```typescript
// packages/core/tools/codebuddy-cli/config-adapter.ts
import fs from 'fs';
import path from 'path';
import { ConfigAdapter, MergeMode } from '@ccman/types';
import { getRootDir } from '../../paths.js';
import { deepMerge } from '../../utils/merge.js';

export class CodeBuddyConfigAdapter implements ConfigAdapter {
  private getPath(pathId: string): string {
    if (pathId !== 'main') {
      throw new Error(`Unknown pathId: ${pathId}`);
    }
    return path.join(getRootDir(), '.codebuddy', 'config.json');
  }

  read(pathId: string): unknown {
    const configPath = this.getPath(pathId);

    // 文件不存在返回空对象
    if (!fs.existsSync(configPath)) {
      return {};
    }

    const content = fs.readFileSync(configPath, 'utf-8');
    return JSON.parse(content);
  }

  write(pathId: string, data: unknown, mode: MergeMode = 'old-override-new'): void {
    const configPath = this.getPath(pathId);

    // 确保目录存在
    const dir = path.dirname(configPath);
    if (!fs.existsSync(dir)) {
      fs.mkdirSync(dir, { recursive: true, mode: 0o700 });
    }

    // 读取现有配置
    const existing = this.read(pathId) || {};

    // 深度合并
    const merged = this.merge(pathId, existing, data, mode);

    // 原子写入
    const tempPath = `${configPath}.tmp`;
    const backupPath = `${configPath}.bak`;

    try {
      // 备份
      if (fs.existsSync(configPath)) {
        fs.copyFileSync(configPath, backupPath);
      }

      // 写入临时文件
      fs.writeFileSync(tempPath, JSON.stringify(merged, null, 2), { mode: 0o600 });

      // 原子替换
      fs.renameSync(tempPath, configPath);
    } catch (error) {
      // 回滚
      if (fs.existsSync(backupPath)) {
        fs.copyFileSync(backupPath, configPath);
      }
      throw error;
    }
  }

  merge(
    pathId: string,
    base: unknown,
    override: unknown,
    mode: MergeMode = 'old-override-new'
  ): unknown {
    if (mode === 'old-override-new') {
      return deepMerge(override, base);  // 老配置优先
    } else {
      return deepMerge(base, override);  // 新配置优先
    }
  }

  validate(pathId: string, data: unknown): void {
    // 可选：验证配置格式
    if (typeof data !== 'object' || data === null) {
      throw new Error('Config must be an object');
    }
  }
}
```

---

## 六、实现 ServiceAdapter

### 6.1 创建 `service-adapter.ts`

```typescript
// packages/core/tools/codebuddy-cli/service-adapter.ts
import { ServiceAdapter, Provider } from '@ccman/types';
import { CodeBuddyConfigAdapter } from './config-adapter.js';

export class CodeBuddyServiceAdapter implements ServiceAdapter {
  private configAdapter = new CodeBuddyConfigAdapter();

  writeOfficial(provider: Provider): void {
    // 读取现有配置
    const config = this.configAdapter.read('main') as any || {};

    // 更新服务商字段
    config.api_endpoint = provider.baseUrl;
    config.api_key = provider.apiKey;

    // 如果有 model 字段
    if (provider.model) {
      if (typeof provider.model === 'string') {
        config.model = provider.model;
      } else {
        // JSON 元数据（如 Gemini）
        config.model = provider.model.defaultModel || 'gpt-4-codebuddy';
      }
    }

    // 写入配置（保留其他字段）
    this.configAdapter.write('main', config, 'old-override-new');
  }

  readCurrent(): Provider | null {
    const config = this.configAdapter.read('main') as any;

    if (!config || !config.api_endpoint) {
      return null;
    }

    return {
      id: 'current',
      name: 'current',
      baseUrl: config.api_endpoint,
      apiKey: config.api_key,
      model: config.model,
      createdAt: 0,
      updatedAt: 0,
    };
  }

  validate(provider: Partial<Provider>): void {
    if (!provider.baseUrl) {
      throw new Error('baseUrl is required');
    }
    if (!provider.apiKey) {
      throw new Error('apiKey is required');
    }
  }
}
```

---

## 七、创建预设（可选）

### 7.1 创建 `presets.ts`

```typescript
// packages/core/tools/codebuddy-cli/presets.ts
import { PresetTemplate } from '@ccman/types';

export const CODEBUDDY_PRESETS: PresetTemplate[] = [
  {
    name: 'official',
    baseUrl: 'https://api.codebuddy.com/v1',
    description: 'CodeBuddy 官方服务',
    isBuiltIn: true,
  },
  {
    name: 'community',
    baseUrl: 'https://community.codebuddy.com/v1',
    description: 'CodeBuddy 社区服务',
    isBuiltIn: true,
  },
];
```

---

## 八、创建配置模板（可选）

### 8.1 创建模板文件

```bash
mkdir -p packages/core/templates/codebuddy-cli
```

### 8.2 创建 `config.json` 模板

```json
{
  "api_endpoint": "{{provider.baseUrl}}",
  "api_key": "{{provider.apiKey}}",
  "model": "{{provider.model|default:'gpt-4-codebuddy'}}",
  "other_settings": {
    "auto_save": true,
    "theme": "dark"
  }
}
```

---

## 九、导出工具

### 9.1 创建 `index.ts`

```typescript
// packages/core/tools/codebuddy-cli/index.ts
export { codebuddyDescriptor } from './descriptor.js';
export { CodeBuddyConfigAdapter } from './config-adapter.js';
export { CodeBuddyServiceAdapter } from './service-adapter.js';
export { CODEBUDDY_PRESETS } from './presets.js';
```

---

## 十、注册工具

### 10.1 修改 `tools/index.ts`

```typescript
// packages/core/tools/index.ts
import { ToolRegistry } from '../core/tool-registry.js';
import { claudeDescriptor } from './claude-code/index.js';
import { codexDescriptor } from './codex/index.js';
import { geminiDescriptor } from './gemini-cli/index.js';
import { codebuddyDescriptor } from './codebuddy-cli/index.js';  // 新增

export function registerAllTools(registry: ToolRegistry): void {
  registry.register(claudeDescriptor);
  registry.register(codexDescriptor);
  registry.register(geminiDescriptor);
  registry.register(codebuddyDescriptor);  // 新增这一行！
}
```

**就这样！无需修改其他任何代码。**

---

## 十一、验证

### 11.1 CLI 自动生成命令

```bash
# CLI 会自动识别新工具
$ ccman cb --help
Usage: ccman cb [command]

Commands:
  add      添加服务商
  list     列出所有服务商
  use      切换服务商
  current  查看当前服务商
  edit     编辑服务商
  remove   删除服务商
  clone    克隆服务商

# 使用命令
$ ccman cb add
? 服务商名称: my-codebuddy
? Base URL: https://api.codebuddy.com/v1
? API Key: cb-xxx
✅ 服务商已添加

$ ccman cb use my-codebuddy
✅ 已切换到 my-codebuddy

# 验证配置已更新
$ cat ~/.codebuddy/config.json
{
  "api_endpoint": "https://api.codebuddy.com/v1",
  "api_key": "cb-xxx",
  "model": "gpt-4-codebuddy",
  "other_settings": {
    "auto_save": true,
    "theme": "dark"
  }
}
```

### 11.2 Desktop 自动渲染 UI

Desktop 会自动在侧边栏显示 "CodeBuddy CLI"，点击后进入服务商管理页面，所有功能（添加、编辑、删除、切换）都自动可用。

---

## 十二、高级功能（可选）

### 12.1 支持 MCP

如果工具支持 MCP，添加 `mcp-adapter.ts`：

```typescript
// packages/core/tools/codebuddy-cli/mcp-adapter.ts
import { McpAdapter, MCPServer } from '@ccman/types';
import { CodeBuddyConfigAdapter } from './config-adapter.js';

export class CodeBuddyMcpAdapter implements McpAdapter {
  private configAdapter = new CodeBuddyConfigAdapter();

  writeOfficial(servers: MCPServer[]): void {
    const config = this.configAdapter.read('main') as any || {};

    // 将 MCPServer[] 转换为工具的配置格式
    config.mcpServers = servers.reduce((acc, server) => {
      acc[server.name] = {
        command: server.command,
        args: server.args,
        env: server.env,
      };
      return acc;
    }, {} as Record<string, any>);

    this.configAdapter.write('main', config, 'old-override-new');
  }

  readAll(): MCPServer[] {
    const config = this.configAdapter.read('main') as any;

    if (!config || !config.mcpServers) {
      return [];
    }

    // 将工具的配置格式转换为 MCPServer[]
    return Object.entries(config.mcpServers).map(([name, server]: [string, any]) => ({
      id: `mcp-${name}`,
      name,
      command: server.command,
      args: server.args || [],
      env: server.env || {},
      enabledApps: ['codebuddy-cli'],
      createdAt: 0,
      updatedAt: 0,
    }));
  }

  validate(servers: MCPServer[]): void {
    // 可选：验证 MCP 配置
  }
}
```

然后在 `descriptor.ts` 中启用：

```typescript
adapters: {
  config: new CodeBuddyConfigAdapter(),
  service: new CodeBuddyServiceAdapter(),
  mcp: new CodeBuddyMcpAdapter(),  // 启用 MCP
},

capabilities: ['service', 'config', 'mcp'],  // 添加 'mcp'
```

### 12.2 支持多配置文件

如果工具有多个配置文件（如 Codex 的 `config.toml` + `auth.json`），在 `configPaths` 中添加：

```typescript
configPaths: [
  {
    id: 'main',
    path: '~/.codebuddy/config.json',
    format: 'json',
    scope: 'user',
  },
  {
    id: 'auth',
    path: '~/.codebuddy/auth.json',
    format: 'json',
    scope: 'user',
  },
],
```

然后在 `ConfigAdapter` 和 `ServiceAdapter` 中分别处理。

---

## 十三、测试

### 13.1 单元测试

```typescript
// packages/core/tools/codebuddy-cli/__tests__/service-adapter.test.ts
import { describe, it, expect, beforeEach } from 'vitest';
import { CodeBuddyServiceAdapter } from '../service-adapter.js';

describe('CodeBuddyServiceAdapter', () => {
  let adapter: CodeBuddyServiceAdapter;

  beforeEach(() => {
    adapter = new CodeBuddyServiceAdapter();
  });

  it('should write provider to config', () => {
    const provider = {
      id: 'test-1',
      name: 'test',
      baseUrl: 'https://test.com',
      apiKey: 'test-key',
      createdAt: 0,
      updatedAt: 0,
    };

    adapter.writeOfficial(provider);

    const current = adapter.readCurrent();
    expect(current?.baseUrl).toBe('https://test.com');
    expect(current?.apiKey).toBe('test-key');
  });

  it('should validate required fields', () => {
    expect(() => {
      adapter.validate({ name: 'test' });
    }).toThrow('baseUrl is required');
  });
});
```

### 13.2 集成测试

```bash
# 设置测试环境
export NODE_ENV=test

# 清理测试目录
rm -rf /tmp/ccman-test

# 运行测试
pnpm test
```

---

## 十四、总结

### 14.1 添加新工具的步骤回顾

1. ✅ 创建工具目录 `packages/core/tools/codebuddy-cli/`
2. ✅ 实现 `ToolDescriptor` （约 30 行）
3. ✅ 实现 `ConfigAdapter` （约 80 行）
4. ✅ 实现 `ServiceAdapter` （约 60 行）
5. ✅ 创建预设 `presets.ts` （约 20 行）
6. ✅ 创建模板文件（可选）
7. ✅ 导出工具 `index.ts` （约 5 行）
8. ✅ 注册工具 `tools/index.ts` （1 行）

**总计：** 约 200-300 行代码，1 行注册代码，0 行 CLI/Desktop 修改。

### 14.2 完成后自动获得的功能

- ✅ CLI 命令自动生成（`ccman cb add/list/use/current/edit/remove/clone`）
- ✅ Desktop UI 自动渲染（侧边栏、服务商管理页面）
- ✅ 预设管理
- ✅ 配置导入导出
- ✅ WebDAV 云同步
- ✅ 零破坏性写入
- ✅ 备份恢复

**真正的可扩展性！**

---

**下一步：** 查看 [迁移计划](./04-迁移计划.md)
