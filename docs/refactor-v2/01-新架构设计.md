# ccman 新架构设计（完全重构版）

> 完全摒弃现有代码设计，采用"工具即插件"架构
>
> **设计原则：** 数据结构优先 + 零破坏性 + 可扩展性

---

## 一、架构总览

### 1.1 核心理念

**现有问题:**
1. 添加新工具需要修改多个文件（虽然已有工厂模式，但不够彻底）
2. 几个工具的行为未完全统一
3. 模板系统未充分利用（部分硬编码）
4. ccman 自身未被抽象成工具实例

**新架构目标:**
- **完全插件化：** 新增工具只需添加工具描述符和适配器
- **统一行为：** 所有工具通过统一接口管理（ServiceAdapter/McpAdapter/ConfigAdapter）
- **模板驱动：** 所有配置通过文件模板生成，无硬编码
- **ccman 抽象：** ccman 自身也是工具实例之一

### 1.2 分层架构

```
┌────────────────────────────────────────────────────┐
│            Interface 层（用户交互）                 │
│  ┌─────────────────┐    ┌──────────────────────┐  │
│  │   CLI Commands  │    │  Desktop (Electron)  │  │
│  │  - 动态生成命令  │    │  - 动态渲染 UI       │  │
│  └────────┬────────┘    └─────────┬────────────┘  │
└───────────┼──────────────────────┼─────────────────┘
            │                      │
┌───────────┴──────────────────────┴─────────────────┐
│          Core Services 层（业务逻辑）                │
│  ┌──────────────────────────────────────────────┐  │
│  │  ProviderService - 服务商管理                 │  │
│  │  McpService - MCP 管理                       │  │
│  │  ConfigService - 配置文件管理                 │  │
│  │  SyncService - WebDAV 同步                   │  │
│  │  ToolOrchestrator - 统一管理接口              │  │
│  └───────────────────┬──────────────────────────┘  │
└────────────────────┼────────────────────────────────┘
                     │
┌────────────────────┴────────────────────────────────┐
│          ToolRegistry（工具注册中心）                │
│  - 管理所有 ToolDescriptor                          │
│  - 提供工具查询和发现                                │
│  - 支持动态加载（未来）                              │
└────────────────────┬────────────────────────────────┘
                     │
┌────────────────────┴────────────────────────────────┐
│        Tool Drivers 层（工具适配器）                 │
│  packages/core/tools/                               │
│  ├── ccman/                                         │
│  │   ├── descriptor.ts                             │
│  │   ├── config-adapter.ts                         │
│  │   └── index.ts                                  │
│  ├── claude-code/                                   │
│  │   ├── descriptor.ts                             │
│  │   ├── config-adapter.ts                         │
│  │   ├── service-adapter.ts                        │
│  │   ├── mcp-adapter.ts                            │
│  │   ├── presets.ts                                │
│  │   └── index.ts                                  │
│  ├── codex/                                         │
│  │   └── ...                                       │
│  ├── gemini-cli/                                    │
│  │   └── ...                                       │
│  └── codebuddy-cli/ (新增示例)                      │
│      └── ...                                       │
└────────────────────┬────────────────────────────────┘
                     │
┌────────────────────┴────────────────────────────────┐
│        Adapters 层（基础设施）                       │
│  - FileSystem (fs, lock, backup, atomic write)     │
│  - TemplateEngine (模板渲染和深度合并)              │
│  - Crypto (AES-256 加密解密)                        │
│  - WebDAV Client                                   │
│  - PathResolver (根目录管理)                        │
└─────────────────────────────────────────────────────┘
```

### 1.3 ASCII 总览图（快速认知）
```
┌───────────────┐     ┌───────────────┐
│     CLI       │     │    Desktop    │
└───────▲───────┘     └───────▲───────┘
        │ 调用 Core API                │
┌───────┴─────────────────────────────┐
│           Core Services             │
│ Provider/Mcp/Config/Sync/Orchestrator│
└───────▲─────────────────────────────┘
        │ 调度 ToolDescriptor+Adapters
┌───────┴─────────────────────────────┐
│            ToolRegistry             │
└───────▲─────────────────────────────┘
        │ 逐工具适配
┌───────┴─────────────────────────────┐
│    Tool Drivers (Config/Service/Mcp)│
└───────▲─────────────────────────────┘
        │ 读写
┌───────┴─────────────────────────────┐
│   Adapters(fs/lock/webdav/crypto)   │
└─────────────────────────────────────┘
```

---

## 二、核心概念

### 2.1 ToolDescriptor（工具描述符）

**定义：** 每个工具的"身份证"，声明工具的能力、配置、适配器等。

```typescript
interface ToolDescriptor {
  // ========== 基础信息 ==========
  id: Tool;                    // 工具唯一 ID，如 'codex' | 'claude-code' | 'gemini-cli'
  short: string;               // 短名称（用于 CLI），如 'cx' | 'cc' | 'gc'
  displayName: string;         // 显示名称（用于 UI），如 'Codex' | 'Claude Code' | 'Gemini CLI'
  description?: string;        // 工具描述（可选）

  // ========== 配置路径 ==========
  configPaths: ConfigPath[];   // 工具的所有配置文件路径

  // ========== 适配器（处理官方配置） ==========
  adapters: {
    config?: ConfigAdapter;    // 配置文件读/写/合并适配器
    service?: ServiceAdapter;  // 服务商 → 官方配置的映射适配器
    mcp?: McpAdapter;          // MCP → 官方配置的映射适配器
  };

  // ========== 模板系统 ==========
  templates?: TemplateSpec[];  // 配置文件模板及占位符

  // ========== 预设 ==========
  presets?: PresetSpec[];      // 内置的服务商/MCP 预设

  // ========== 能力声明 ==========
  capabilities: ('service'|'mcp'|'config')[];
  // - 'service': 支持服务商管理
  // - 'mcp': 支持 MCP 管理
  // - 'config': 支持配置文件管理
}
```

**ConfigPath（配置路径）**
```typescript
interface ConfigPath {
  id: string;                  // 配置文件 ID，如 'main' | 'auth' | 'env'
  path: string;                // 文件路径（支持 ~ 展开），如 '~/.codex/config.toml'
  format: 'json' | 'toml' | 'env';  // 文件格式
  scope?: 'user' | 'project' | 'system';  // 作用域（Gemini 等支持多层配置）
  readonly?: boolean;          // 是否只读
}
```

**TemplateSpec（模板规范）**
```typescript
interface TemplateSpec {
  pathId: string;              // 对应 ConfigPath.id
  templatePath: string;        // 模板文件路径（相对于 core/templates）
  placeholders?: Record<string, string>;  // 占位符映射（可选）
}
```

### 2.2 Adapter（适配器）

**ConfigAdapter（配置适配器）**
```typescript
interface ConfigAdapter {
  // 读取配置文件
  read(pathId: string): unknown;

  // 写入配置文件（支持合并模式）
  write(pathId: string, data: unknown, mode?: MergeMode): void;

  // 深度合并配置
  merge(pathId: string, base: unknown, override: unknown, mode?: MergeMode): unknown;

  // 验证配置格式
  validate?(pathId: string, data: unknown): void;
}

type MergeMode = 'new-override-old' | 'old-override-new';
```

**ServiceAdapter（服务商适配器）**
```typescript
interface ServiceAdapter {
  // 将 Provider 写入工具的官方配置文件
  writeOfficial(provider: Provider): void;

  // 从官方配置文件读取当前 Provider（如果有）
  readCurrent?(): Provider | null;

  // 验证 Provider 必填字段
  validate(provider: Partial<Provider>): void;
}
```

**McpAdapter（MCP 适配器）**
```typescript
interface McpAdapter {
  // 将 MCPServer[] 写入工具的官方配置文件
  writeOfficial(servers: MCPServer[]): void;

  // 从官方配置文件读取所有 MCP 服务器
  readAll?(): MCPServer[];

  // 验证 MCP 配置
  validate?(servers: MCPServer[]): void;
}
```

---

## 三、Core Services（核心服务）

### 3.1 ToolRegistry（工具注册中心）

```typescript
class ToolRegistry {
  private tools: Map<Tool, ToolDescriptor> = new Map();

  // 注册工具
  register(descriptor: ToolDescriptor): void;

  // 获取工具描述符
  get(tool: Tool): ToolDescriptor;

  // 列出所有工具
  list(): ToolDescriptor[];

  // 检查工具是否存在
  has(tool: Tool): boolean;

  // 根据短名称查找工具
  getByShort(short: string): ToolDescriptor | undefined;

  // 根据能力查找工具
  filterByCapability(capability: 'service' | 'mcp' | 'config'): ToolDescriptor[];
}
```

### 3.2 ProviderService（服务商管理）

```typescript
class ProviderService {
  constructor(private registry: ToolRegistry) {}

  // ========== CRUD 操作 ==========

  // 列出所有服务商
  list(tool: Tool): Provider[];

  // 添加服务商
  add(tool: Tool, input: ProviderInput): Provider;

  // 更新服务商
  update(tool: Tool, name: string, data: Partial<ProviderInput>): Provider;

  // 删除服务商
  delete(tool: Tool, name: string): void;

  // ========== 应用操作 ==========

  // 应用服务商（写入官方配置）
  apply(tool: Tool, name: string): Provider;

  // ========== 其他操作 ==========

  // 克隆服务商
  clone(tool: Tool, sourceName: string, newName: string, overrides?: Partial<ProviderInput>): Provider;

  // 获取当前服务商
  current(tool: Tool): Provider | null;

  // 根据 ID 获取服务商
  get(tool: Tool, id: string): Provider;

  // 根据 name 查找服务商
  findByName(tool: Tool, name: string): Provider | undefined;
}
```

### 3.3 McpService（MCP 管理）

```typescript
class McpService {
  constructor(private registry: ToolRegistry) {}

  // ========== CRUD 操作 ==========

  // 列出所有 MCP 服务器
  list(): MCPServer[];

  // 添加 MCP 服务器
  add(input: MCPServerInput): MCPServer;

  // 更新 MCP 服务器
  update(name: string, data: Partial<MCPServerInput>): MCPServer;

  // 删除 MCP 服务器
  delete(name: string): void;

  // ========== 应用操作 ==========

  // 应用 MCP 到指定工具
  apply(name: string, targetTools: Tool[]): MCPServer;

  // ========== 查询操作 ==========

  // 获取 MCP 启用的工具列表
  getEnabledApps(name: string): Tool[];

  // 根据 ID 获取 MCP
  get(id: string): MCPServer;

  // 根据 name 查找 MCP
  findByName(name: string): MCPServer | undefined;
}
```

### 3.4 ConfigService（配置管理）

```typescript
class ConfigService {
  constructor(private registry: ToolRegistry) {}

  // 列出工具的所有配置文件路径
  listPaths(tool: Tool): Record<string, string>;

  // 读取配置文件
  get(tool: Tool, pathId?: string): Record<string, unknown> | Record<string, Record<string, unknown>>;

  // 更新配置文件
  update(tool: Tool, pathId: string, data: unknown, opts?: { mode?: MergeMode }): void;
}
```

### 3.5 ToolOrchestrator（统一管理接口）

**目的：** 提供更高层次的接口，同时更新 ccman 存储和工具官方配置。

```typescript
class ToolOrchestrator {
  constructor(
    private providerService: ProviderService,
    private mcpService: McpService
  ) {}

  // ========== 服务商管理（ccman + 工具官方配置） ==========

  // 为工具应用服务商
  applyToolService(tool: Tool, name: string): Provider {
    // 1. 调用 ProviderService.apply() 写入官方配置
    // 2. 更新 ccman 存储的 currentProviderId
    // 3. 返回 Provider
  }

  // 为工具添加服务商
  addToolService(tool: Tool, input: ProviderInput): Provider {
    // 调用 ProviderService.add()
  }

  // 为工具更新服务商
  updateToolService(tool: Tool, name: string, data: Partial<ProviderInput>): Provider {
    // 调用 ProviderService.update()
  }

  // 为工具删除服务商
  deleteToolService(tool: Tool, name: string): void {
    // 调用 ProviderService.delete()
  }

  // ========== MCP 管理（ccman + 工具官方配置） ==========

  // 为工具应用 MCP
  applyToolMcp(name: string, targetTools: Tool[]): MCPServer {
    // 调用 McpService.apply()
  }

  // 其他 MCP 方法代理...
}
```

---

## 四、数据流示例

### 4.0 服务总览（链路快照）
```
applyService -> ProviderService -> ServiceAdapter -> 官方配置文件
applyMcp     -> McpService      -> McpAdapter     -> 官方配置文件
sync.merge   -> SyncService     -> MergePlanner   -> Provider/Mcp/ConfigServices
```

### 4.1 服务商切换流程

```
用户执行: ccman cc use claude-official

         ↓

CLI Command Handler
  ↓ 调用 ToolOrchestrator.applyToolService('claude-code', 'claude-official')
         ↓

ToolOrchestrator
  ↓ 调用 ProviderService.apply('claude-code', 'claude-official')
         ↓

ProviderService
  ├─ 1. 从 ccman 存储读取 Provider (ToolConfig)
  ├─ 2. 调用 ToolRegistry.get('claude-code') 获取 ToolDescriptor
  ├─ 3. 调用 ServiceAdapter.writeOfficial(provider)
  │      ↓
  │   ServiceAdapter (claude-code)
  │   ├─ 加载模板 (templates/claude/settings.json)
  │   ├─ 替换占位符 ({{provider.apiKey}}, {{provider.baseUrl}})
  │   ├─ 与现有配置深度合并 (old-override-new)
  │   └─ 写入 ~/.claude/settings.json
  └─ 4. 更新 ccman 存储的 currentProviderId

         ↓

返回更新后的 Provider
```

### 4.2 MCP 应用流程

```
用户执行: ccman mcp edit server1 --enable claude,gemini

         ↓

CLI Command Handler
  ↓ 调用 McpService.apply('server1', ['claude-code', 'gemini-cli'])
         ↓

McpService
  ├─ 1. 从 ccman 存储读取 MCPServer
  ├─ 2. 更新 enabledApps = ['claude-code', 'gemini-cli']
  ├─ 3. 对每个工具:
  │      ├─ ToolRegistry.get(tool) 获取 ToolDescriptor
  │      └─ McpAdapter.writeOfficial([server1, ...])
  │         ↓
  │      McpAdapter (claude-code)
  │      └─ 写入 ~/.claude/settings.json 的 mcpServers 字段
  │         ↓
  │      McpAdapter (gemini-cli)
  │      └─ 写入 ~/.gemini/settings.json 的 mcpServers 字段
  └─ 4. 保存到 ccman 存储 (~/.ccman/mcp.json)

         ↓

返回更新后的 MCPServer
```

---

### 4.3 WebDAV 合并流程（ASCII）
```
SyncService.merge
   │
   ├─ 下载 & 解密云端快照
   ├─ 读取本地快照
   ├─ MergePlanner(diff Providers / MCP / Config)
   │     ├─ 对 Providers 调 ProviderService
   │     ├─ 对 MCP 调 McpService
   │     └─ 对 Config 调 ConfigService
   ├─ 写回本地（锁+备份+模板合并）
   └─ 重新加密上传 → 返回 SyncReport(新增/更新/删除/冲突/备份)
```

### 4.4 自愈与托管字段（行为约束）
- 缺失目录/文件：读操作返回 `{}` 并自动创建目录(0o700)/文件(0o600)，不抛错；写操作仍走备份→临时→rename。
- 托管字段（仅这些会被覆盖，其余保留用户内容）：
  - Claude Code: `settings.json` → `env.ANTHROPIC_AUTH_TOKEN`, `env.ANTHROPIC_BASE_URL`.
  - Codex: `config.toml` → `model_provider`, `model`, `[model_providers.<name>]`；`auth.json` → `OPENAI_API_KEY`.
  - Gemini CLI: `.env` → `GEMINI_API_KEY`, `GOOGLE_GEMINI_BASE_URL`, `GEMINI_MODEL` 及 provider.model JSON 中声明的 `env`; `settings.json` 仅在缺失时补 ide/security 基础键。

## 五、模板系统

### 5.1 模板文件组织

```
packages/core/templates/
├── codex/
│   ├── config.toml         # Codex 主配置模板
│   └── auth.json           # Codex 认证配置模板
├── claude/
│   └── settings.json       # Claude 配置模板
├── gemini/
│   ├── settings.json       # Gemini 主配置模板
│   └── .env                # Gemini 环境变量模板
└── ccman/
    ├── codex.json          # ccman 存储 Codex Provider 的模板
    ├── claude.json         # ccman 存储 Claude Provider 的模板
    ├── gemini.json         # ccman 存储 Gemini Provider 的模板
    └── mcp.json            # ccman 存储 MCP 的模板
```

**模板文件化/合并原则**
- 模板必须以原生格式存放于 `packages/core/templates/<tool>/`，禁止内联字符串。
- 默认合并策略 `old-override-new`（保留用户自定义）；调用方可传 `MergeMode` 覆盖。
- 占位符仅覆盖托管字段，其余字段原样保留，确保零破坏写入。

### 5.2 模板占位符规范

**Claude 模板示例：** `templates/claude/settings.json`
```json
{
  "env": {
    "ANTHROPIC_AUTH_TOKEN": "{{provider.apiKey}}",
    "ANTHROPIC_BASE_URL": "{{provider.baseUrl}}",
    "CLAUDE_CODE_DISABLE_NONESSENTIAL_TRAFFIC": 1,
    "CLAUDE_CODE_MAX_OUTPUT_TOKENS": 32000
  },
  "permissions": {
    "allow": [],
    "deny": []
  }
}
```

**Codex 模板示例：** `templates/codex/config.toml`
```toml
model_provider = "{{provider.name}}"
model = "{{provider.model|default:'gpt-5-codex'}}"
model_reasoning_effort = "high"
disable_response_storage = true

[model_providers.{{provider.name}}]
name = "{{provider.name}}"
base_url = "{{provider.baseUrl}}"
wire_api = "responses"
requires_openai_auth = true
```

### 5.3 TemplateEngine（模板引擎）

```typescript
class TemplateEngine {
  // 加载模板文件
  static load(templatePath: string): string;

  // 替换占位符
  static render(template: string, data: Record<string, any>): string;

  // 深度合并配置（支持模式选择）
  static merge(base: unknown, override: unknown, mode: MergeMode = 'old-override-new'): unknown;
}
```

**占位符语法：**
- 简单替换：`{{provider.apiKey}}`
- 默认值：`{{provider.model|default:'gpt-5-codex'}}`
- 条件渲染（可选）：`{{#if provider.model}}...{{/if}}`

### 5.4 在 Adapter 中使用模板

```typescript
class ClaudeServiceAdapter implements ServiceAdapter {
  private templates: TemplateSpec[] = [
    {
      pathId: 'main',
      templatePath: 'templates/claude/settings.json',
    },
  ];

  writeOfficial(provider: Provider): void {
    // 1. 加载模板
    const template = TemplateEngine.load(this.templates[0].templatePath);

    // 2. 替换占位符
    const rendered = TemplateEngine.render(template, { provider });

    // 3. 读取现有配置
    const existingConfig = this.read('main') || {};

    // 4. 深度合并（老配置优先，保留用户自定义）
    const mergedConfig = TemplateEngine.merge(existingConfig, JSON.parse(rendered), 'old-override-new');

    // 5. 原子写入
    this.write('main', mergedConfig);
  }
}
```

---

## 六、环境与路径管理

### 6.1 根目录决策

**决策顺序（优先级从高到低）：**
```
1. CCMAN_ROOT 环境变量（最高优先级，可覆盖一切）
2. ~/.ccmanrc 或 ~/.ccman/paths.json 持久化配置
3. NODE_ENV=test → /tmp/ccman-test（固定，无 PID）
4. NODE_ENV=development → /tmp/ccman-dev
5. 默认 → os.homedir()
```

**实现：**
```typescript
// packages/core/paths.ts
let CURRENT_ROOT: string | null = null;

export function getRootDir(): string {
  if (CURRENT_ROOT) return CURRENT_ROOT;

  // 1. 环境变量
  if (process.env.CCMAN_ROOT) {
    return process.env.CCMAN_ROOT;
  }

  // 2. 持久化配置
  const rcPath = path.join(os.homedir(), '.ccmanrc');
  if (fs.existsSync(rcPath)) {
    const config = JSON.parse(fs.readFileSync(rcPath, 'utf-8'));
    if (config.rootDir) return config.rootDir;
  }

  // 3. NODE_ENV 检测
  if (process.env.NODE_ENV === 'test') {
    return '/tmp/ccman-test';
  }

  if (process.env.NODE_ENV === 'development') {
    return '/tmp/ccman-dev';
  }

  // 4. 默认
  return os.homedir();
}

export function setRootDir(root: string): void {
  CURRENT_ROOT = root;

  // 持久化到 ~/.ccmanrc
  const rcPath = path.join(os.homedir(), '.ccmanrc');
  fs.writeFileSync(rcPath, JSON.stringify({ rootDir: root }, null, 2));
}
```

### 6.2 所有路径基于 rootDir

```typescript
export function getCcmanDir(): string {
  return path.join(getRootDir(), '.ccman');
}

export function getCodexDir(): string {
  return path.join(getRootDir(), '.codex');
}

export function getClaudeDir(): string {
  return path.join(getRootDir(), '.claude');
}

export function getGeminiDir(): string {
  return path.join(getRootDir(), '.gemini');
}
```

**好处：**
- 单点切换：修改根目录后，所有工具路径自动更新
- 持久化：进程重启后仍然生效
- 灵活性：支持环境变量覆盖、持久化配置、NODE_ENV 自动检测
- 测试友好：测试环境固定路径 `/tmp/ccman-test`，测试前清理即可

---

## 七、安全与可靠性

### 7.1 零破坏性写入

**原则：** 仅覆盖托管字段，保留用户自定义配置

**实现：**
1. **写入前备份：** 创建 `.bak` 文件
2. **深度合并：** 模板 + 现有配置深度合并（old-override-new）
3. **原子写入：** 先写临时文件，再 `fs.rename()`
4. **失败回滚：** 出错时从 `.bak` 恢复

```typescript
function safeWrite(filePath: string, content: string): void {
  const backupPath = `${filePath}.bak`;
  const tempPath = `${filePath}.tmp`;

  try {
    // 1. 备份现有文件
    if (fs.existsSync(filePath)) {
      fs.copyFileSync(filePath, backupPath);
    }

    // 2. 写入临时文件
    fs.writeFileSync(tempPath, content, { mode: 0o600 });

    // 3. 原子替换
    fs.renameSync(tempPath, filePath);
  } catch (error) {
    // 4. 失败回滚
    if (fs.existsSync(backupPath)) {
      fs.copyFileSync(backupPath, filePath);
    }
    throw error;
  }
}
```

### 7.2 文件权限

- **配置文件：** `0o600` (仅用户可读写)
- **目录：** `0o700` (仅用户可访问)

### 7.3 锁机制

使用 `proper-lockfile` 防止并发写入：

```typescript
import lockfile from 'proper-lockfile';

function writeWithLock(filePath: string, content: string): void {
  const release = await lockfile.lock(filePath, { retries: 5 });

  try {
    safeWrite(filePath, content);
  } finally {
    release();
  }
}
```

---

## 八、对比总结

| 维度 | 现有架构 | 新架构 |
|------|---------|--------|
| **扩展性** | 添加新工具需改多个文件 | 只需添加工具描述符和适配器 |
| **统一性** | 工具行为未完全统一 | 所有工具通过统一接口管理 |
| **模板** | 部分硬编码在代码中 | 完全文件模板驱动 |
| **ccman 抽象** | ccman 未被抽象 | ccman 也是工具实例之一 |
| **CLI/Desktop** | 每个工具硬编码命令/UI | 动态生成命令和 UI |
| **测试路径** | `/tmp/ccman-test-{PID}` | `/tmp/ccman-test`（固定）|
| **根目录切换** | 不支持持久化 | 支持持久化配置 |

---

## 九、关键收益

1. **真正的可扩展性：** 添加新工具只需 200-300 行代码，无需修改 Core/CLI/Desktop
2. **完全解耦：** Core Services 不依赖具体工具实现
3. **类型安全：** 通过 TypeScript 接口约束所有适配器
4. **模板统一：** 所有工具使用相同的模板引擎和合并策略
5. **测试友好：** 每个 Adapter 可独立单元测试
6. **向后兼容：** 保留兼容层，平稳迁移

---

**下一步：** 查看 [核心 API 定义](./02-核心API定义.md)
